\Chapter{Problem układania planu lekcji i algorytm jego rozwiązania}\label{chapter:algorytm}
    Opis struktury rozdziału.
    % Chociaż czyste podejście MIP prowadzi do teoretycznie optymalnych rozwiązań, w praktyce jego zastosowanie do pełnego problemu jest niemożliwe.
    % Złożoność obliczeniowa i pamięciowa przekracza możliwości przeciętnych komputerów, co uniemożliwia efektywny rozwój takiego rozwiązania.
    % Ponadto takie rozwiązanie jest też trudne do zaprogramowania ze względu na bloki lekcyjne.

    % Zaprezentowane podejście hybrydowe pozwala pokonać problem złożoności obliczeniowej, oferując praktyczny kompromis między optymalnością a czasem obliczeń.

    \section{Sformułowanie problemu optymalizacyjnego}
        Na potrzeby pracy warto ujednolicić terminologię, z uwagi na to, że w języku potocznym niektóre z tych terminów są używane zamiennie:
        \begin{itemize}
            \item \textbf{Klasa}: Grupa uczniów; przykładowo ``IIA'', ``IVC'', \dots
            Ze względu na angielską nazwę \textit{class}, która koliduje ze składnią języków programowania, w kodzie często odnoszę się do klas jako \verb|student_group|.
            \item \textbf{Sala}: Miejsce, w którym prowadzone są zajęcia; przykładowo ``Sala Gimnastyczna 1'', ``2'', \dots
            \item \textbf{Przedmiot}: Temat zajęć prowadzonych przez nauczyciela; przykładowo ``Wychowanie Fizyczne'', ``Matematyka'', \dots
            \item \textbf{Lekcja}: Zajęcia prowadzone przez jednego nauczyciela, w jednej sali, z jedną lub więcej klas, które są na temat jednego przedmiotu.
            \item \textbf{Slot czasowy}: Czas w którym odbywa się lekcja; przykładowo slot zerowy może odbywać się od 7:00 do 7:45.
            \item \textbf{Blok lekcyjny}: Grupa dwóch lub więcej lekcji, które odbywają się w tym samym slocie czasowym.
            Mogą one dotyczyć jednej klasy oraz wielu nauczycieli, jednego nauczyciela i wielu klas, lub też wielu klas i wielu nauczycieli.
            \item \textbf{Okienko}: Przerwa między dwoma lekcjami klasy lub nauczyciela. Występuje gdy zajęcia nie są przeprowadzane bezpośrednio po sobie.
        \end{itemize}

        Słownik oznaczeń:
        \begin{itemize}
            \item $\mathcal{C}$ --- zbiór klas
            \item $\mathcal{T}$ --- zbiór nauczycieli  
            \item $\mathcal{S}$ --- zbiór przedmiotów
            \item $\mathcal{R}$ --- zbiór sal
            \item $\vec{R_{i}}$ --- zbiór przedmiotów obsługiwanych przez $i$-tą salę
            \item $\mathcal{W}$ --- zbiór wymagań głównych
            \item $\mathcal{L}$ --- zbiór bloków lekcyjnych
            \item $\mathcal{B}$ --- zbiór bloków przedmiotów
            \item $H$ --- liczba slotów czasowych w dniu
            \item $V$ --- wektor godzin bloków
            \item $S$ --- macierz przydziału do dni, kodowanie osobnika
        \end{itemize}

        Problem optymalizacyjny w tej pracy polega na przypisaniu lekcji do odpowiednich slotów czasowych i sal przy jednoczesnym spełnieniu wymagań.
        W rzeczywistości sformułowanie takiego zadania i wyznaczenie jego rozwiązania stanowi duże wyzwanie.
        Istnieją ograniczenia, które są różne dla każdej klasy, co utrudnia formułowanie problemu --- wiele lekcji jest realizowanych w blokach, które są definiowane każdy z osobna.
        Przez te wyjątki nie jest możliwym wykorzystanie prostych algorytmów.
        Nie jest także możliwym rozwiązanie jednego wielkiego problemu programowania całkowitoliczbowego w sensownym czasie przy użyciu komputera z przeciętną specyfikacją.

        Oczekiwanym rezultatem działania algorytmu powinno być pięć zbiorów przypisań $\mathcal{Z}$. Każde takie przypisanie powinno mieć 6 wartości:\label{fragment:przypisania}
        \[ z_i \triangleq \left(d_{z_i},h_{z_i},c_{z_i},t_{z_i},s_{z_i},r_{z_i}\right) \in \mathcal{Z}_d, \quad \forall i \in \left\{1, 2, \dots, \left|\mathcal{Z}_d\right|\right\}: \begin{cases} d_{z_i} &\in \left\{1, 2, 3, 4, 5\right\} \\h_{z_i} &\in \left\{1, 2, \dots, H\right\}\\ c_{z_i} &\in \mathcal{C}\\ t_{z_i} &\in \mathcal{T}\\s_{z_i} &\in \mathcal{S}\\r_{z_i} &\in \mathcal{R} \end{cases} \]
        Przykładowe interpretacje takich przypisań:
        \begin{itemize}
            \item Poniedziałek, Slot czasowy 0, IA,\ \ Sala nr 1, nauczyciel francuskiego 1, język francuski
            \item Poniedziałek, Slot czasowy 0, IIA, Sala nr 1, nauczyciel francuskiego 1, język francuski
            \item[$\vdots$]
            \item Piątek, Slot czasowy 10, IVC, Sala nr 15, nauczyciel fizyki 2, fizyka
        \end{itemize}
        W przypadku lekcji, która obejmują więcej klas niż jedna, należy stworzyć przypisanie dla każdej klasy osobno.

        Proces tworzenia takich przypisań można rozbić na 3 etapy:
        \begin{enumerate}
            \item \textbf{Tworzenie bloków lekcyjnych} $\mathcal{L}$ z ograniczeń głównych $\mathcal{W}$ na podstawie $\mathcal{B}$:
            \begin{itemize}
                \item Łączenie ograniczeń głównych w lekcje międzyklasowe.
                \item Łączenie lekcji międzyklasowych w bloki lekcyjne.
                \item Łączenie ograniczeń głównych w bloki lekcyjne.
            \end{itemize}
            \item \textbf{Przydział bloków lekcyjnych do poszczególnych dni tygodnia $S$.}
            \begin{itemize}
                \item Przykładowo: dwie godziny matematyki w poniedziałek, godzina matematyki w środę, dwie godziny matematyki w czwartek i zero w piątek.
            \end{itemize}
            \item \textbf{Tworzenie samych przypisań $\mathcal{Z}$ dla każdego dnia tygodnia osobno.}
        \end{enumerate}
        
        \subsection{Dane i szukane}
            \subsubsection{Wymagania główne}
                Warto zacząć od przedstawienia sposobu reprezentacji zmiennych w kodzie zaczynając od wymagań głównych.
                Ilość godzin tygodniowo odbytych przez klasę z danym nauczycielem w ramach danego przedmiotu musi być równa ilości przypisanej w pierwszym etapie układania planu.
                Aby łatwiej zrozumieć na czym polega takie przypisanie warto spojrzeć na dotychczasowy sposób przypisywania ilości godzin nauczycieli do klas (Rysunek~\ref{fig:excel_wymagania}) w liceum, które dostarczyło dane na potrzeby tej pracy.
            
                \begin{figure}[ht]
                    \centering
                    \includegraphics[width=0.9\textwidth]{images/excel_wymagania.png}
                    \caption{Zrzut ekranu z arkusza kalkulacyjnego przedstawiąjący przypisanie godzinowe nauczycieli dla każdej klasy.}\label{fig:excel_wymagania}
                \end{figure}
                Każdy nauczyciel jest przypisany do prowadzonych przez niego przedmiotów. 
                Następnie w odpowiednim wierszu nauczyciela, pod odpowiednim przedmiotem, w kolumnie każdej klasy definiowana jest ilość godzin, która będzie poświęcona na prowadzenie tego przedmiotu.

                Zbiór takich wymagań $\mathcal{W}$ definiuje się następująco:
                \[ w_i \triangleq \left(t_{w_i}, c_{w_i}, s_{w_i}, g_{w_i}\right) \in \mathcal{W}, \quad \forall i \in \left\{1, 2, \dots, \left|\mathcal{W}\right|\right\}: \begin{cases} t_{w_i} &\in \mathcal{T}\\c_{w_i} &\in \mathcal{C}\\s_{w_i} &\in \mathcal{S}\\g_{w_i} &\in \mathbb{N}^+ \end{cases}  \]
                gdzie $g_{w_i}$ to liczba wymaganych tygodniowo godzin przedmiotu $s_{w_i}$ przeprowadzonego przez nauczyciela $t_{w_i}$ dla klasy $c_{w_i}$.

                Ponadto każdy nauczyciel ma też zdefiniowaną dostępność, która jest reprezentowana przez macierz $A$ o wymiarach $\left|\mathcal{T}\right|$ na $5$, gdzie $\left|\mathcal{T}\right|$ to liczba wszystkich nauczycieli.
                Macierz jest zero-jedynkowa, gdzie 1 oznacza, że $t$-ty nauczyciel jest dostępny $d$-tego dnia tygodnia, a 0 że jest niedostepny.
                \[ A = \begin{bmatrix}
                    a_{1,1} & a_{1,2} & \cdots & a_{1,5} \\
                    a_{2,1} & a_{2,2} & \cdots & a_{2,5} \\
                    \vdots & \vdots & \ddots  & \vdots  \\
                    a_{\left|\mathcal{T}\right|,1} & a_{\left|\mathcal{T}\right|,2} & \cdots & a_{\left|\mathcal{T}\right|,5} \\
                \end{bmatrix}, \quad \forall t \in \mathcal{T}, \forall d \in \left\{1, 2, 3, 4, 5\right\}: a_{t, d} \in \left\{0, 1\right\} \]
                
                W celu tworzenia bloków mamy także dostęp do zbioru bloków przedmiotów $\mathcal{B}$:\label{subject_blocks}
                \[
                    b_i \triangleq \left(\vec{S_{b_i}},\vec{C_{b_i}}, \vec{G_{b_i}}, \verb|is_aggregating|_{b_i}, \verb|max_weekly|_{b_i}\right) \in \mathcal{B}
                \]
                \[ \forall i \in \left\{1, 2, \dots, \left|\mathcal{B}\right|\right\}: \begin{cases}
                    \vec{S_{b_i}} &\subset \mathcal{S} \\
                    \vec{C_{b_i}} &\subseteq  \mathcal{C} \\
                    \vec{G_{b_i}} &\in \mathbb{N}^{\left|\vec{S_b}\right|} \\
                    \verb|is_aggregating|_{b_i} &\in \left\{0, 1\right\} \\
                    \verb|max_weekly|_{b_i} & \in \mathbb{N}
                \end{cases} \]
                gdzie
                \begin{itemize}
                    \item $\vec{S_{b_i}}$ to podzbiór wszystkich przedmitów, których dotyczy blok $b_i$,
                    \item $\vec{C_{b_i}}$ to podzbiór wszystkich klas, których dotyczy blok $b_i$,
                    \item $\vec{G_{b_i}}$ to wektor oczekiwanej liczby przedmiotów w bloku.
                    \item $\verb|is_aggregating|$ to wartość binarna informująca o tym czy blok jest \textit{agregujący}.
                    \item $\verb|max_weekly|$ to liczba naturalna która informuje o maksymalnej liczbie bloków. Jeśli $\verb|max_weekly|=0$ to oznacza to, że liczba bloków jest nielimitowana.
                \end{itemize}
                Przykładowy blok przedmiotów:
                \begin{itemize}
                    \item $\vec{S_b} = \textit{(język angielski, informatyka)}$,
                    \item $\vec{C_b} = \text{(IA, IB, IC)}$,
                    \item $\vec{G_b} = \left(1, 1\right)$,
                    \item $\verb|is_aggregating| = 0$, \textit{(To nie jest blok argumentujący)}
                    \item $\verb|max_weekly| = 0$, \textit{nielimitowana tygdniowo liczba godzin}
                \end{itemize}
                lub:
                \begin{itemize}
                    \item $\vec{S_b} = \textit{(język angielski)}$,
                    \item $\vec{C_b} = \mathcal{C}$
                    \item $\vec{G_b} = \left(2\right)$,
                    \item $\verb|is_aggregating| = 0$
                    \item $\verb|max_weekly| = 0$
                \end{itemize}
        
        \subsection{Ograniczenia}\label{subsection:ograniczenia}
            Wcześniej wspomniane ograniczenia można podzielić na 4 kategorie:

            \subsubsection{Ograniczenia fizyczne}
                \begin{itemize}
                    \item Żaden nauczyciel nie może być w 2 miejscach na raz.
                    \[ \forall i, j \in \left\{1, 2, \dots, \left|\mathcal{Z}\right|\right\}: r_{z_i} = r_{z_j} \implies t_{z_i} \neq t_{z_j} \]
                    \item Nauczyciel musi być dostępny.
                    \[ \forall i \in \left\{1, 2, \dots, \left|\mathcal{Z}\right|\right\}: a_{t_{z_i},d_{z_i}} = 1 \]
                    Ze względu na charakter pracy nauczyciele często są zmuszeni do pracy w wielu miastach w wielu szkołach.
                    Bardzo rzadko dochodzi do sytuacji, gdzie nauczyciel faktycznie jest w stanie wyrobić pełen etat w jednej szkole, w szczególności w małych wsiach i miastach.
                    Układając plan musimy brać pod uwagę ich dostępność.
                    \item Żaden uczeń nie może być w 2 miejscach na raz.
                    \begin{align*}
                        \forall i, j \in \left\{1, 2, \dots, \left|\mathcal{Z}\right|\right\}, \exists k \in \left\{1, 2, \dots \left|\mathcal{B}\right|\right\}:\\
                        \left(d_{z_i} = d_{z_j} \land h_{z_i} = h_{z_j} \land c_{z_i} = c_{z_j}\right) \implies c_{z_i} \in \vec{C_{b_k}} \land s_{z_i},s_{z_j} \in \vec{S_{b_k}}
                    \end{align*}
                    \item W żadnej sali nie mogą odbywać się 2 lekcje na raz.
                    \begin{align*}
                        \forall i, j \in \left\{1, 2, \dots, \left|\mathcal{Z}\right|\right\}, \exists k \in \left\{1, 2, \dots \left|\mathcal{B}\right|\right\}:\\
                        \left(d_{z_i} = d_{z_j} \land h_{z_i} = h_{z_j} \land r_{z_i} = r_{z_j}\right) \implies s_{z_i} = s_{z_j} \land s_{z_i}, s_{z_j} \in \vec{S_{b_k}}
                    \end{align*}
                \end{itemize}
            
            \subsubsection{Ograniczenia prawne}~\cite{karta_nauczyciela, prawo_oswiatowe, obwieszczenie}
                \begin{itemize}
                    \item Uczeń nie może mieć więcej niż 2 godzin lekcyjnych tego samego przedmiotu dziennie.
                    \[ \forall d \in \left\{1, 2, 3, 4, 5\right\}, c \in \mathcal{C}, s \in \mathcal{S}: \left|\left\{z_i: z_i \in \mathcal{Z} \land d_{z_i} = d \land c_{z_i} = c \land s_{z_i} = s\right\}\right| \leq 2 \]
                    \item Jeśli danego dnia mają zostać przeprowadzone 2 godziny jednego przedmiotu, to uczeń musi je mieć bezpośrednio po sobie.
                    \begin{align*}
                        \forall i, j \in \left\{1, 2, \dots, \left|\mathcal{Z}\right|\right\}, c \in \mathcal{C}, s \in \mathcal{S}:\\
                        \left(d_{z_i} = d_{z_j} \land c_{z_i} = c_{z_j} \land s_{z_i} = s_{z_j}\right) \implies \left|h_{z_i} - h_{z_j}\right| = 1
                    \end{align*}
                \end{itemize}

            \subsubsection{Ograniczenia jakościowe}
                \begin{itemize}
                    \item Brak okienek dla uczniów.
                    \begin{align*}
                        \nexists i, j \in \left\{1, 2, \dots, \left|\mathcal{Z}\right|\right\}, c \in \mathcal{C}:\\
                        d_{z_i} = d_{z_j} \land c_{z_i} = c_{z_j} \land \left|h_{z_i} - h_{z_j}\right| > \left|\left\{z_k: d_{z_k} = d_{z_i} \land c_{z_i}\right\}\right|
                    \end{align*}
                    \item Odpowiednie przypisanie sal. Lekcje wychowania fizycznego muszą odbyć się w przeznaczonych do tego salach, podobnie lekcji informatyki itd.
                    \[ \forall z \in \mathcal{Z}: s_z \in R_{r_z} \]
                \end{itemize}
 

\section{Poprzednie podejścia}
    Aby w pełni zrozumieć mój wybór narzędzi warto szybko przetoczyć historię moich poprzednich podejść do rozwiązania tego problemu.
    
    \subsection{Programowanie zero-jedynkowe}\label{subsection:podejscie_zerojedynkowe}
        Moim pierwszym podejściem była próba użycia tylko i wyłącznie pakietu optymalizacyjnego \textit{IBM ILOG CPLEX}.
        Problem zdefiniowałem używając zmiennych binarnych, tworząc sześcio wymiarową macierz:
        \begin{enumerate}
            \item Wymiar nauczycieli
            \item Wymiar klas
            \item Wymiar przedmiotów
            \item Wymiar dnia
            \item Wymiar slotu czasowego
            \item Wymiar sal
        \end{enumerate}

        Jak można zauważyć złożoność pamięciowa takiego podejścia uniemożliwia jego efektywne skalowanie.
        Nawet dla danych średniej szkoły, mającej mniej niż 100 sal, nauczycieli, klas i przedmitów, taka macierz zajmowała setki GB pamięci RAM.
        Rozwiązaniem tego problemu było zastosowanie słownika z wartościami jako zmienne binarne i kluczami jako krotki 6 liczb całkowitych:
        
        \[ X = \left\{\left(t, c, d, h, s, r\right): x_{t, c, d, h, s, r}\right\}, \quad \begin{cases}
            t & \in \left\{1, 2, \dots \mathfrak{T}\right\} \\
            c & \in \left\{1, 2, \dots \mathfrak{C}\right\} \\
            d & \in \left\{1, 2, \dots 5\right\} \\
            h & \in \left\{1, 2, \dots \mathfrak{H}\right\} \\
            s & \in \left\{1, 2, \dots \mathfrak{S}\right\} \\
            r & \in \left\{1, 2, \dots \mathfrak{R}\right\} \\
        \end{cases} \]
        \begin{align*}
            \forall &t \in \left\{1, 2, \dots \mathfrak{T}\right\} ,c \in \left\{1, 2, \dots \mathfrak{C}\right\} ,d \in \left\{1, 2, \dots 5\right\} ,\\
            &h \in \left\{1, 2, \dots \mathfrak{H}\right\} ,s \in \left\{1, 2, \dots \mathfrak{S}\right\} ,r \in \left\{1, 2, \dots \mathfrak{R}\right\}: \quad x_{\left(t, c, d, h, s, r\right)} \in \left\{0, 1\right\}
        \end{align*}
        gdzie 
        \begin{itemize}
            \item $\mathfrak{T}$ to liczba nauczycieli,
            \item $\mathfrak{C}$ to liczba klas,
            \item $H$ to wartości horyzontu,
            \item $\mathfrak{S}$ to liczba przedmiotów,
            \item $\mathfrak{R}$ to liczba dostępnych sal,
            \item $d$ reprezentuje dzień tygodnia,
            \item $h$ reprezentuje slot czasowy.
        \end{itemize}
        W ten sposób pozbywam się wszystkich niemożliwych wartości, przykładowo wychowania fizycznego z nauczycielem matematyki.
        Używając tej metody nadal możemy używać intuicji, która towarzyszy z macierzą.
        Musimy tylko sprawdzać czy dane zmienne binarne faktycznie istnieją.

        Jest to intuicyjny sposób poradzenia sobie z problemem harmonogramowania zajęć o niezmiennej długości jednego slotu czasowego.
        Bardzo łatwo można definiować ograniczenia fizyczne.
        \begin{itemize}
            \item Ograniczenie prowadzenia maksymalnie jednej lekcji dla wszystkich nauczycieli:
            \[ \forall t \in \left\{0, 1, 2, \dots, \mathfrak{T}\right\}, \quad \sum_{c=0}^{\mathfrak{C}} \sum_{s=0}^{\mathfrak{S}} \sum_{d=1}^{5} \sum_{h=0}^{H} \sum_{r=0}^{\mathfrak{R}} x_{t,c,s,d,h,r} = 1 \]
            \item Ograniczenie posiadania maksymalnie jednej lekcji w jednym slocie czasowym dla wszystkich uczniów:
            \[ \forall c \in \left\{0, 1, 2, \dots, \mathfrak{C}\right\}, \quad \sum_{t=0}^{\mathfrak{T}} \sum_{s=0}^{\mathfrak{S}} \sum_{d=1}^{5} \sum_{h=0}^{H} \sum_{r=0}^{\mathfrak{R}} x_{t,c,s,d,h,r} = 1 \]
            \item Ograniczenie maksymalnie jednej lekcji w pokoju:
            \[ \forall r \in \left\{0, 1, 2, \dots, \mathfrak{R}\right\}, \quad \sum_{t=0}^{\mathfrak{T}} \sum_{s=0}^{\mathfrak{S}} \sum_{d=1}^{5} \sum_{h=0}^{H} \sum_{c=0}^{\mathfrak{C}} x_{t,c,s,d,h,r} = 1 \]
        \end{itemize}
        Tak zdefiniowany problem bardzo szybko znajdował rozwiązania, które spełniały wszystkie ograniczenia fizyczne.

        Problemem tego rozwiązania jest niemożność wprowadzenia bloków lekcyjnych przy jednoczesnym zachowaniu prostoty obliczeniowej.
        Kolejnym wyzwaniem było również wprowadzenie minimalizacji liczby okienek dla nauczycieli oraz wprowadzenie wymagania ciągłości zajęć dla wszystkich klas.
        Zmienne binarne nie oferują wystarczającej wszechstronności, która jest potrzebna w układaniu planów zajęć.
    
    \subsection{Grafowe sieci neuronowe}
        W odpowiedzi na problemy z MIP, zdecydowałem się na zbadanie alternatywnych metod rozwiązania.
        Wybrałem niekonwencjonalną reprezentację problemu harmonogramowania używając grafowych sieci neuronowych~\cite{schlichtkrull2018modeling}.
        W przyjętym modelu problem został przedstawiony w postaci grafu, gdzie węzły reprezentowały wymagania główne (\ref{subsubsection:ograniczenie_glowne}), 
            a krawędzie łączyły zajęcia o tych samych nauczycielach lub tych samych klasach.

        Taka reprezentacja okazała się szczególnie atrakcyjna pod względem implementacji funkcji celu.
        Ocena dopuszczalności rozwiązania sprowadzała się do weryfikacji spełnienia ograniczeń, które można było w prosty sposób zamodelować za pomocą funkcji kary
        Jednocześnie można nagradzać model za przypisywanie lekcji do poprawnych bloków.
        Początkowe rezultaty były bardzo obiecujące --- model już po kilkadziesięciu epokach wykazywał zdolność do identyfikowania, które lekcji powinny być w blokach, a które wymagają rozdzielenia w celu uniknięcia kolizji.

        Główną wadą w tym podejściu okazał się brak gwarancji spełnienia ograniczeń twardych oraz trudności przy układaniu planu iteracyjnie (lekcja po lekcji).
        Eksperymenty wykazały, że przy zastosowaniu zbyt wysokich współczynników kary, proces uczenia nie przynosił rezultatów. 
        Zbyt niskie natomiast powodowały, że model preferował optymalizację nagrody za grupowanie lekcji kosztem naruszenia ograniczeń.

\section{Struktura algorytmu i wybór technologii}
    W świetle przeprowadzonych eksperymentów i poprzednich prób rozwiazania problemu zauważyłem, że poleganie wyłącznie na metodach inteligentnych lub MIP nie doprowadzi do sensownych rezultatów.
    Główna innowacja zaproponowanego rozwiązania leży w dekompozycji oryginalnego zadania na trzy sekwencyjne fazy, co nie było obecne w moich pierwszych próbach.
    Zadaniem pierwszych dwóch jest zmniejszenie przestrzeni decyzyjnej do coraz mniejszej skali, tak aby w ostatniej fazie można było sformułować i rozwiązać problem programowania całkowitoliczbowego (MIP).
    Rezultatem takiego podejścia jest redukcja liczby zmiennych decyzyjnych, potrzebnych do zdefiniowania ograniczeń w trzecim etapie.

    Zdecydowałem się na użycie trzech następujących technik:
    \begin{enumerate}
        \item Algorytmu zachłannego do tworzenia bloków lekcyjnych z ograniczeń głównych.
        \item Algorytmu ewolucyjnego do przydziału bloków lekcyjnych do poszczególnych dni tygodnia.
        \item Programowania liniowego do tworzenia przypisań opisanych w sekcji~\ref{fragment:przypisania} dla każdego dnia osobno.
    \end{enumerate}
    Ze względu na prostotę integracji z backendem aplikacji użyłem języka programowania Python.
    Otwarta natura narzędzia Google OR-Tools oraz jego wygodne API w Pythonie skłoniło mnie do decyzji przeciwko CPLEX i Gurobi.

\section{Algorytm zachłanny}
    Algorytm zachłanny (ang. \textit{greedy}) polega na iteracyjnym podejmowaniu lokalnie najlepszej decyzji bez cofania się i bez globalnego przeszukiwania przestrzeni rozwiązań~\cite{cormen2022introduction}.
    Choć w wielu problemach algorytm zachłanny daje rozwiązania przybliżone, w zadaniach konstrukcyjnych, w których celem jest wyłącznie znalezienie wszystkich maksymalnych (niedających się już powiększyć) struktur, jego prostota jest zaletą: eliminuje zbędną warstwę optymalizacji.

    W etapie budowy bloków lekcyjnych nie maksymalizujemy funkcji celu ani nie porównujemy jakości wariantów --- każdy poprawny (zgodny z ograniczeniami) blok jest akceptowalny.
    Celem jest:
    \begin{enumerate}
        \item Pokrycie wszystkich wymagań głównych.
        \item Rozpatrzenie wszystkich bloków przedmiotów.
        \item Utworzenie możliwie największych spójnych bloków (maksymalnych względem liczby składowych wymagań głównych).
        \item Uniknięcie duplikacji i kolizji (spełnienie ograniczeń).
    \end{enumerate}
    
    Problem sprowadza się do iterowania się po blokach przedmitów i tworzenia wszystkich, maksymalnie dużych, bloków lekcyjnych.
    Próba użycia metod optymalizacyjnych (MIP, metaheurystyki) na tym etapie wprowadzałaby koszt obliczeniowy bez zysku jakościowego: już sam algorytm zachłanny pozwala na stworzenie maksymalnie dużych bloków.
    Algorytm zachłanny pozwala szybko eksplorować przestrzeń lokalną: dla każdej potencjalnej konfiguracji rozszerzamy blok dopóki wszystkie warunki (brak konfliktu nauczycieli, zgodność klas, \dots) pozostają spełnione.
    Po wyczerpaniu możliwości blok osiąga swoją maksymalną wielkość.
    Wielkość innych bloków nie wpływa na ten wynik, co oznacza, że rozwiązanie optymalne lokalnie jest również optymalne globalnie.

    \subsection{Bloki lekcyjne}
        Operując na blokach lekcyjnych duży łatwiej zdefiniować ograniczenia fizyczne.
        Weźmy na przykład 3 lekcje: Język Niemiecki, Język Francuski oraz Język Rosyjski.
        Gdybyśmy mieli definiować dla nich ograniczenie określające, że żaden uczeń nie może mieć przypisanych dwóch lub więcej lekcji w tym samym czasie, musielibyśmy zapewnić, że żadna z tych lekcji nie pokrywa się z innymi lekcjami tej klasy, takimi jak Matematyka czy Fizyka, 
            przy jednoczesnym zapewnieniu, że te lekcji mogą się na siebie nałożyć.
        Te zajęcia stanowią obowiązkowy język dodatkowy, który uczniowie wybierają każdy z osobna.
        Każdy uczeń może wybrać tylko jeden język, co za tym idzie lekcje mogą odbywać się niezależnie od siebie.
        Grupując takie ograniczenia główne w bloki 3 lekcji możemy potraktować taki blok jak każdą inną lekcję przy definiowaniu ograniczeń ---
        nie może być przypisany do tego samego slotu czasowego z żadną inną lekcją.

        Następną zaletą jest prostota w projektowaniu ograniczeń dla lekcji, które odbywają się dla więcej niż jednej klasy.
        Często w szkołach brakuje uczniów zapisanych na przykładowo Język Rosyjski w jednej klasie, aby uzasadnić indywidualną lekcję prowadzoną przez nauczyciela z tylko i wyłącznie jedną klasą.
        W takich przypadkach szkoła definiuje lekcje, które nauczyciel prowadzi dla wielu klas jednocześnie.
        Podobnie jak w poprzednim przykładzie, definiowanie ograniczeń dla każdej lekcji z osobna wiąże się z wyjątkami.
        Jeśli natomiast połączymy wymagania główne dla paru klas w jeden blok, możemy go traktować tak jak każdą inną lekcję.

        Kolejną zaletą tego rozwiązania jest możliwość łączenia bloków w jeszcze większe bloki.
        Wyobraźmy sobie sytuację, w której mamy trzy klasy: IIIA, IIIB i IIIC, oraz 3 przedmioty do przeprowadzenia: Język Niemiecki, Język Francuski i Język Rosyjski.
        Z uwagi na niską liczbę uczniów zapisanych na rosyjski i francuski te zajęcia sa prowadzone w następujących grupach:
        \begin{itemize}
            \item wszystkie 3 klasy mają razem Język Rosyjski,
            \item klasa IIIA i IIIB mają razem Język Francuski, a klasa IIIC ma indywidualnie z innym nauczycielem,
            \item każda klasa ma indywidualnie Język Niemiecki, z czego klasa IIIA i IIIC mają tego samego nauczyciela.
        \end{itemize}
        Jak można łatwo zauważyć wszystkie te lekcji poza jedną lekcją języka niemieckiego mogą odbyć się jednocześnie.
        Po stworzeniu wieloklasowych bloków lekcyjnych możemy je łączyć dalej.
        Język Rosyjski może być połączony z blokiem Języka Francuskiego dla klas IIIA i IIIB oraz lekcją klasy IIIC.
        Do tego możemy też dodać dwie lekcje języka Niemieckiego pozostawiając ostatnią lekcję poza blokiem ze względu na kolizję nauczycieli.

    \subsection{Działanie}
        \textbf{Dane wejściowe}
        \begin{itemize}
            \item $\mathcal{B}$
            \item $\mathcal{W}$
        \end{itemize}

        \textbf{Klasyfikacja bloków}
        \begin{itemize}
            \item \textbf{Bloki pojedyncze} --- obejmują pojedyncze klasy
            \item \textbf{Bloki wieloklasowe} --- łączą wymagania z wielu klas dla tych samych przedmiotów
            \item \textbf{Bloki agregujące} --- tworzą wyższy poziom hierarchii, łącząc istniejące bloki i wymagania w jeszcze większe bloki
        \end{itemize}

        \textbf{Działanie}
            \begin{enumerate}
                \item \textbf{Inicjalizacja struktur danych:}
                \begin{itemize}
                    \item Słownik śledzący wykorzystanie godzin wymagań
                    \item Listy przechowujące pogrupowane wymagania
                \end{itemize}
                \item \textbf{Tworzenie bloków wieloklasowych:}
                \begin{itemize}
                    \item Grupowanie wymagań według przedmiotów i klas zdefiniowanych w blokach wieloklasowych
                    \item Każda grupa tworzy potencjalny blok lekcyjny
                \end{itemize}

                \item \textbf{Agregacja bloków:}
                \begin{itemize}
                    \item Łączenie bloków wieloklasowych w większe jednostki
                    \item Unikanie konfliktów nauczycieli poprzez śledzenie wykorzystanych pedagogów
                    \item Przydział godzin oparty na minimalnym wymaganiu w grupie
                \end{itemize}

                \item \textbf{Generowanie bloków pojedynczych:}
                \begin{itemize}
                    \item Tworzenie kombinacji wymagań dla pojedynczych klas
                    \item Uwzględnienie przypadków z wieloma nauczycielami tego samego przedmiotu
                    \item Walidacja zgodności z definicjami bloków
                \end{itemize}

                \item \textbf{Iteracyjna alokacja godzin:}
                \begin{itemize}
                    \item Równomierny przydział pozostałych godzin do bloków
                    \item Respektowanie maksymalnych limitów tygodniowych
                    \item Gwarancja wykorzystania wszystkich wymaganych godzin
                \end{itemize}

                \item \textbf{Finalizacja:}
                \begin{itemize}
                    \item Dodanie pozostałych wymagań jako bloków jednostkowych
                    \item Zwrócenie listy bloków i odpowiadających im godzin
                \end{itemize}
            \end{enumerate}

        % \textbf{Procedura}\\
        % Warto zwrócić uwagę na blok różnicę między ``blokiem przedmiotów'' a ``blokiem lekcyjnym''. Blok przedmiotów to byt, który jest definiowany przez uzytkownika w celu tworzenia przez algorytm bloków lekcyjnych.
        % \begin{enumerate}
        %     \item Podzielenie bloków na 3 grupy:
        %     \begin{enumerate}
        %         \item Bloki, gdzie zbiór klas ma więcej niż $\frac{1}{2} \mathfrak{G}$ elementów, lub dokładnie 1 element, gdzie $\mathfrak{G}$ to liczba wszystkich klas. Na potrzeby dalszych rozważań nazwijmy je \textit{pojedynczymi blokami}.
        %         \begin{itemize}
        %             \item W praktyce te bloki służą definiowaniu bloków lekcyjnych, które zamykają się w obrębie jednej klasy, przykładowo wszystkie klasy w szkole moją używać bloków wychowanie fizyczne chłopaków + wychowanie fizyczne dziewczyn.
        %         \end{itemize}
        %         \item Bloki agregujące.
        %         \begin{itemize}
        %             \item Te bloki służa agregowaniu innych bloków, przykładowo dwóch \textit{multi-bloków} języka francuskiego dla klasy IIA, IIB i IIC oraz języka niemieckiego dla klasy IIA i IIB.
        %         \end{itemize}
        %         \item Pozostałe bloki. Na potrzeby dalszych rozważań nazwijmy je \textit{multi-blokami}.
        %         \begin{itemize}
        %             \item Jak opisałem powyżej te bloki służą tworzeniu międzyklasowych bloków lekcyjnych.
        %         \end{itemize} 
        %     \end{enumerate}
        %     \item Tworzymy słownik, który posłuży nam jako późniejsze wyjście:
        %     \begin{itemize}
        %         \item \verb|return_blocks|, gdzie kluczami są bloki lekcyjne, a wartościami ich wymagana liczba tygodniowo.
        %     \end{itemize}
        %     \item Tworzymy słownik \verb|requirement_corrections|, gdzie klucze to ograniczenia główne a wartości to liczby naturalne.
        %     \item Tworzymy pustą listę \verb|multi_req_groups|, która będzie przechowywać zbiory wymagań głównych.
        %     \item Dla każdego $i$-tego bloku w zbiorze \textit{multi-bloków} dodajemy do \verb|multi_req_groups| krotkę z wszystkimi wymaganiami spełniających następujące warunki:
        %     \begin{enumerate}
        %         \item Ich przedmiot znajduje się w zbiorze przedmiotów $i$-tego bloku przedmiotów.
        %         \item Ich klasa znajduję się w zbiorze klas $i$-tego bloku przedmiotów.
        %     \end{enumerate} 
        %     \item Tworzymy pustą listę \verb|power_blocks|, która będzie przechowywać zbiory wymagań głównych.
        %     \item Dla każdego bloku agregującego $i$:
        %     \begin{enumerate}
        %         \item Tworzymy zbiór \verb|used_teachers| w celu uniknięcia kolizji nauczycieli.
        %         \item Tworzymy tymczasową listę \verb|tmp|, która będzie gromadzić wszystkie ograniczenia główne spełniające określone wymagania.
        %         \item Dodajemy do zbioru \verb|tmp| ograniczenia zapisane w krotce $j$ w \verb|multi_req_groups| jeśli:
        %         \begin{enumerate}
        %             \item Klasy wszystkich wymagań w $j$-tej krotce znajdują się w zbiorze klas $i$-tego bloku przedmiotów.
        %             \item Przedmioty wszystkich wymagań w $j$-tej krotce znajdują się w zbiorze przedmiotów $i$-tego bloku przedmiotów.
        %             \item Nauczyciel wszystkich wymagań w $j$-tej krotce nie znajduje się w zbiorze \verb|used_teachers|.
        %             \item Żadno wymaganie w $j$-tej krotce nie zostało wcześniej użyte do stworzenia agregacyjnego bloku lekcyjnego.
        %         \end{enumerate}
        %         \item Dodajemy do zbioru \verb|tmp| wszystkie ograniczenia ze zbioru wszystkich wymagań głównych ograniczenia w $j$-tej krotce w \verb|multi_req_groups| jeśli:
        %         \begin{enumerate}
        %             \item Nauczyciej danego wymagania nie znajduje się w zbiorze \verb|used_teachers|.
        %             \item Klasa i przedmiot zgadza się z $i$-tym blokiem agregującym.
        %         \end{enumerate}
        %         \item Jeśli dodajemy ograniczenia do \verb|tmp|, to dodajemy ich nauczycieli do \verb|used_teachers|.
        %         \item W \verb|requirement_corrections| zapisujemy wartość minimalnej liczby wymaganych godzin wszystkich dodanych ograniczeń głównych pod kluczami odpowiednich ograniczeń. Robiąc to, efektywnie tworzymy blok lekcyjny i przypisujemy mu największą możliwą liczbę godzin tygodniowo. W przypadku bloków agregacyjnych ograniczenia główne bardzo często mają taką samą liczbę wymaganych godzin tygodniowo.
        %         \item Do \verb|return_blocks| zapisujemy \verb|tmp| z wartością minimalnej liczby godzin.
        %     \end{enumerate}
        %     \item Tworzymy pustą listę \verb|silgular_req_groups|, która będzie przechowywać
        %     \item Dla każdego $i$-tego bloku w zbiorze \textit{pojedynczych bloków} i dla każdej klasy $g$:
        %     \begin{enumerate}
        %         \item Tworzymy zbiór wymagań \verb|reqs| dla klasy $g$ i dla przedmiotów zdefiniowanych w $i$-tym bloku.
        %         \item Jeśli klasa $g$ znajduje się w $i$-tym bloku przedmiotów oraz wartości \verb|requirement_corrections| dla wszystkich wymagań w \verb|reqs| są mniejsze niż ich liczba godzin ogarniczeń głównych to:
        %         \begin{enumerate}
        %             \item Jeśli liczba wymaganych przedmiotów zgadza się z tą zdefiniowaną w $i$-tym bloku to dodajemy \verb|reqs| do \verb|silgular_req_groups|.
        %             \item W przyciwnym przypadku tworzymy wszystkie możliwe kombinacje (o długości równej sumie wymaganych przedmiotów) wymagań głównych znajdujących się w \verb|reqs| i dodajemy te kombinacje, które są zgodne z wymaganą liczbą przedmiotów.
        %             Jest to pomocne w przypadkach kiedy na przykład mame zdefiniowany blok przedmiotów z jedną informatyką oraz jednym językiem angielskim.
        %             Klasy często mają zajęcia języka angielskiego z dwoma nauczycielami --- w takim przypadku \verb|reqs| ma w sobie trzy wymagania.
        %             Tworząc kombinacje o długości dwóch wymagań gwarantujemy, że dodamy informatykę z jednym angielskim oraz informatykę z drugim angielskim.
        %         \end{enumerate}
        %     \end{enumerate}
        %     \item Dla każdego bloku, którego wszystkie wymagania główne mają liczbę godzin większą niż odpowiadającą im wartość w \verb|requirement_corrections|
        %     oraz każdego bloku, którego maksymalna liczba tygodniowo nie została przekroczona:
        %     \begin{enumerate}
        %         \item Dla każdego wymagania głównego w bloku zwiększamy jego wartość w \verb|requirement_corrections| o 1.
        %     \end{enumerate}
        %     W ten sposób gwarantujemy równomierne stworzenie bloków. Jest to przydatne przykładowo w wyżej opisanym przykładzie z blokiem inf+ang --- mamy dwa takie bloki dla każdej klasy, aby nie przypisać dwóch godzin do pierwszego i zero do drugiego bloku lekcyjnego musimy obrać takie iteracyjne podejście.
        %     \item Dla wszystkich wymagań w zbiorze wszystkich wymagan głównych dla których wartość w \verb|requirement_corrections| jest mniejsza niż ich wymagana liczba godzin tygodniowo:
        %     \begin{enumerate}
        %         \item Do \verb|return_blocks| zapisujemy blok lekcyjny z jednym wymaganiem głównym jako klucz i różnicą między wymaganiem głównym a wartością z \verb|requirement_corrections|.
        %     \end{enumerate}
        %     \item Zwracamy listę kluczy $B$ oraz macierz wymaganych godzin $V$ z wartościami słownika \verb|return_blocks|.
        % \end{enumerate}

        Wynikiem działania algorytmu zachłannego jest efektywna reprezentacja bloków gotowa do dalszego generowania planu.
        Algorytm zwraca:
        \begin{itemize}
            \item Zbiór bloków lekcyjnych $\mathcal{L}$, gdzie każdy blok $L_i$ jest wekrotem zbiorem wymagań głównych:
            \[ \mathcal{L} = \left\{L_1, L_2, L_{\mathfrak{N}}\right\}, \quad \forall i \in \left\{1, 2, \dots, \mathfrak{N}\right\}: L_i \subset \mathcal{W} \]
            gdzie $\mathfrak{N}$ to liczba wszystkich bloków.
            \item Macierz wymagań głównych bloków --- liczby godzin tygodniowych, gdzie $v_i$ oznacza liczbę godzin przeznaczonych na blok $b_i$ na przestrzeni tygodnia. 
            \[ V = \begin{bmatrix} v_1 & v_2 & \cdots & v_\mathfrak{N} \end{bmatrix}, \quad \forall i \in \left\{1, 2, \dots, \mathfrak{N}\right\}: v_i \in \mathbb{N}^+ \]
        \end{itemize}
        
    \subsection{Przykładowe rezultaty}

\section{Algorytm ewolucyjny}
    Algorytm ewolucyjny jest populacyjną metodą przeszukiwania inspirowaną mechanizmami doboru naturalnego: selekcją, krzyżowaniem i mutacją.
    Klasyczne podstawy teorii zaprezentował Holland~\cite{holland1992genetic}.
    W odróżnieniu od podejść gradientowych lub zachłannych algorytm genetyczny eksploruje wiele konkurujących rozwiązań równolegle, co ułatwia balansowanie kilku kryteriów jakości oraz unikanie wczesnego utknięcia na lokalnych wierzchołkach funkcji celu.

    W mojej pracy algorytm ewolucyjny pełni rolę drugiego etapu dekompozycji: po redukcji problemu do listy bloków lekcyjnych pozostaje dyskretne zadanie rozdziału tygodniowych godzin każdego bloku na pięć dni roboczych przy prostych ograniczeniach.

    Zastosowany algorytm ewolucyjny wnosi:
    \begin{enumerate}
        \item \textbf{Naturalną obsługę wielu kryteriów} poprzez dodawanie komponentów funkcji przystosowania.
        \item \textbf{Specjalistyczne operatory} krzyżowania i mutacji działające na poziomie kolumn (bloków), co zachowuje poprawność bez kosztownych procedur naprawczych.
        \item \textbf{Niską złożoność obliczeniową} dzięki małej liczbie zmiennych w jednym osobniku (5 wartości na blok) i możliwości jednoczesnego oceniania całej populacji używając operacji na macierzach.
        \item \textbf{Łatwe dostrajanie wag} (priorytety klas kontra nauczyciele) bez zmian w strukturze modelu.
    \end{enumerate}

    Ogólna struktura algorytmu:
    \begin{center}
        \begin{algorithm}[H]
            \caption{``The general scheme of an evolutionary algorithm in pseudocode''\cite{eiben2015evolutionary}}
            \SetAlgoLined
            
            INITIALISE population with random individuals\;
            EVALUATE each individual\;
            
            \Repeat{TERMINATION CONDITION is satisfied}{
                SELECT parents\;
                RECOMBINE pairs of parents\;
                MUTATE the resulting offspring\;
                EVALUATE new individuals\;
                SELECT individuals for the next generation\;
            }
        \end{algorithm}
    \end{center}
    gdzie w mojej pracy:
    \begin{itemize}
        \item \verb|INITIALISE| reprezentuje budowę pierwszej populacji (\ref{subsection:generowanie_populacji}) przez losowe generowanie kolumn zgodnie z dostępnością i wymaganiami bloków.
        \item \verb|EVALUATE| oblicza wartości funkcji przystosowania (\ref{subsection:przystosowanie}) dla każdego osobnika według zdefiniowanych metryk.
        \item \verb|SELECT parents| realizuje selekcję probabilistyczną (\ref{subsection:selekcja}) z przewagą lepiej ocenionych osobników.
        \item \verb|RECOMBINE pairs of parents| tworzy potomków (\ref{subsection:krzyzowanie}) przez kolumnowe dziedziczenie struktur bloków (bez łamania ograniczeń).
        \item \verb|MUTATE the resulting offspring| wprowadza różnorodność przez rekonstrukcję wybranych kolumn (\ref{subsection:mutacja}) z rozkładu wielomianowego.
        \item \verb|SELECT individuals for the next generation| implementuje elitaryzm i utrzymuje stały rozmiar populacji.
        \item \verb|TERMINATION CONDITION| kończy proces po ustalonej liczbie generacji.
    \end{itemize}

    \subsection{Cel algorytmu}
        Algorytm ma na celu przydział godzin lekcyjnych z macierzy bloków $V$ do pięciu roboczych dni tygodnia reprezentowanych przez macierz $S$~(\ref{specimen}).
        Dla każdego bloku generowanych jest pięć wartości całkowitoliczbowych reprezentujących liczbę godzin lekcyjnych przydzielonych do poszczególnych dni, przy zachowaniu wymagań wynikających z poprzedniego etapu przetwarzania.
        Końcowy przydział godzin powinien mieć następujące cechy:
        \begin{itemize}
            \item Spełnione ograniczenia twarde
            \item Równomierny przydział bloków na przestrzeni tygodnia dla klas
            \item Równomierny przydział bloków na przestrzeni tygodnia dla nauczycieli
        \end{itemize}

        \subsubsection{Dane wejściowe}
            \begin{itemize}
                \item $\mathcal{L}$
                \item $V$
                \item $A$
                \item $\mathcal{B}$
                \item $\mathcal{C}$ 
                \item $\mathcal{T}$ 
                \item $\mathcal{S}$
            \end{itemize}
        
        \subsubsection{Dane wyjściowe}
            \begin{itemize}
                \item Poprawna macierz $S_{\text{best}}$:
                \begin{itemize}
                    \item spełniająca wszystkie ograniczenia twarde,
                    \item posiadająca satysfakcjonującą wartość funkcji przystosowania.
                \end{itemize} 
            \end{itemize}

    \subsection{Kodowanie i ograniczenia twarde}\label{subsection:kodowanie}
        Każdy osobnik w populacji jest reprezentowany przez macierz przydziałów $S$ o wymiarach $5 \times \mathfrak{N}$.
        \begin{equation}\label{specimen}
             S = \begin{bmatrix}
                s_{1,1} & s_{1,2} & s_{1,3} & \cdots & s_{1, \mathfrak{N}} \\
                s_{2,1} & s_{2,2} & s_{2,3} & \cdots & s_{2, \mathfrak{N}} \\
                s_{3,1} & s_{3,2} & s_{3,3} & \cdots & s_{3, \mathfrak{N}} \\
                s_{4,1} & s_{4,2} & s_{4,3} & \cdots & s_{4, \mathfrak{N}} \\
                s_{5,1} & s_{5,2} & s_{5,3} & \cdots & s_{5, \mathfrak{N}} \\
            \end{bmatrix}, \quad S \in \mathbb{N}^2 
        \end{equation}
        gdzie $s_{d,i}$ oznacza liczbę godzin $i$-tego bloku lekcyjnego $L_i$ przydzielonych do $d$-tego dnia tygodnia.

        Tak przyjęta reprezentacja umożliwia prostą weryfikację następujących ograniczeń:
        \begin{enumerate}
            \item Całkowita liczba godzin każdego bloku musi odpowiadać wymaganiom określonym w macierzy $V$.
            \[ \forall i \in \left\{1, 2, \dots, \mathfrak{N}\right\}: \sum_{d=1}^{5} s_{d,i} = v_i \]
            \item Maksymalna liczba godzin każdego bloku w pojedynczym dniu nie może być większa niż 2.
            \[ \forall i \in \left\{1, 2, \dots, \mathfrak{N}\right\}, \forall d \in \left\{1, 2, 3, 4, 5\right\}: s_{d, i} \leq 2 \]
            \item Dla bloków 3-godzinnych konieczne jest przedzielenie 2 godzin do jednego dnia.
            \[ \forall i \in \left\{1, 2, \dots, \mathfrak{N}\right\}: v_{i} = 3 \implies \exists d \in \left\{1, 2, 3, 4, 5\right\} \text{ takie, że } s_{d, i} = 2 \]
        \end{enumerate}

    \subsection{Generowanie populacji początkowej}\label{subsection:generowanie_populacji}
        Generowanie osobników odbywa się losowo z uwzględnieniem wymagań bloków oraz dostępności nauczycieli. 
        Wykorzystuję w tym celu rozkład wielomianowy~\cite{feller1971introduction}, który zapewnia spełnienie podstawowych ograniczeń. 
        Proces generowania pojedynczego osobnika składa się z następujących etapów wykonywanych dla każdego $i$-tego bloku:
        \begin{enumerate}
            \item \textbf{Zagregowanie dostępności nauczycieli:}\\
            Dla każdego dnia wyznaczana jest dostępność wszystkich nauczycieli przypisanych do $i$-tego bloku.
            \[ \forall d \in \{1,2,3,4,5\}: a_d' = \min_{t \in T_i} a_{t,d} \]
            gdzie $T_i = \{t_{w_j} : w_j \in L_i\}$ to zbiór nauczycieli w bloku $L_i$.
            \item \textbf{Jeśli $v_i = 3$ to:}
            \begin{enumerate}
                \item $X_i \gets \begin{bmatrix} 0 & 0 & 0 & 0 & 0 \end{bmatrix}$
                \item $k, l \gets \text{losowe dni, dla których } a'_i = a'_j = 1$
                \item $x_k \gets 2, x_l \gets 1$
            \end{enumerate}
            Po wykonaniu tych kroków generowanie dla bieżącego bloku jest zakończone.
            \item \textbf{Stworzenie macierzy prawdopodobieństw wystąpienia bloku w danym dniu:}\\
            Tworzymy wektor prawdopodobieństw:
            \begin{align*}
                P &= \begin{bmatrix} \frac{a'_1}{\sum_{i=1}^{5}a'_i} & \frac{a'_2}{\sum_{i=1}^{5}a'_i} & \frac{a'_3}{\sum_{i=1}^{5}a'_i} & \frac{a'_4}{\sum_{i=1}^{5}a'_i} & \frac{a'_5}{\sum_{i=1}^{5}a'_i} \end{bmatrix} \\
                P &= \begin{bmatrix} p_1 & p_2 & p_3 & p_4 & p_5 \end{bmatrix}
            \end{align*}
            tak stworzone prawdopodobieństwa zapewniają, że $p_d = 0$ jeśli którykolwiek nauczyciel jest niedostępny $d$-tego dnia oraz $\sum_{d=1}^{5} p_d = 1$.
            \item \textbf{Losowanie z rozkładu wielomianowego:}\\
            Korzystając z implementacji biblioteki \verb|numpy|~\cite{numpymultinomialdocs}, generowana jest próbka:
            \[ \verb|numpy.random.multinomial(r,| \begin{bmatrix} p_1 & p_2 & \cdots & p_5 \end{bmatrix}\verb|)| \]
            Wynikiem tej funkcji jest macierz $X_i = \begin{bmatrix} x_0 & x_1 & \cdots & x_5 \end{bmatrix}$, która ze względu na własności rozkładu spełnia:
            \[ \begin{cases}
                    x_d \in \mathbb{N} & \forall d \in \left\{1, 2, \dots, 5\right\} \\
                    \sum_{d=1}^{5} x_d = v_i & 
                \end{cases} \]
            \item \textbf{Korekcja przekroczeń limitu dziennego:}\\
            Dopóki $\exists d \in \left\{1, 2, 3, 4, 5\right\} : x_d > 2$:
            \begin{enumerate}
                \item Dla każdego $d \in \left\{1, 2, 3, 4, 5\right\}$ spełniającego $x_d > 2$:
                \begin{enumerate}
                    \item $X_i' \gets \verb|numpy.random.multinomial(|x_d - 2\verb|, |P\verb|)|$
                    \item $x_d \gets 2$
                    \item $X_i \gets X_i + X_i'$
                \end{enumerate}
            \end{enumerate}
        \end{enumerate}

        Po wykonaniu powyższej procedury dla wszystkich bloków, uzyskane wektory $X_i$ łączy się w macierz:
        \[ X = \begin{bmatrix} X_1 \\ X_2 \\ \vdots \\ X_\mathfrak{N} \end{bmatrix} \]
        Osobnik populacji reprezentowany jest przez transpozycję tej macierzy: $S = X^T$.

    \subsection{Przystosowanie}\label{subsection:przystosowanie}
        Ocena jakości osobników odbywa się na podstawie czterech niezależnych metryk:        
        \begin{itemize}
            \item Równomierność rozkładu godzin pracy nauczycieli w ciągu tygodnia
            \item Równomierność rozkładu godzin lekcyjnych klas w ciągu tygodnia
            \item Liczba dni, w których nauczyciele muszą pojawić się w szkole
            \item Różnica między najdłuższym i najkrótszym dniem lekcyjnym dla klas
        \end{itemize}
        
        W początkowej fazie prac wykorzystałem funkcję gęstości rozkładu normalnego z wartością oczekiwaną $\mu = 8$, co wynika z ośmiogodzinnego dnia pracy. 
        Okazało się jednak, że takie podejście zapewniało wyłącznie nagrody, nie oferując mechanizmu karania niepożądanych rozwiązań.
        Ograniczało to zdolność algorytmu do korekcji błędów.
        W odpowiedzi na te wyzwania zaprojektowałem funkcję kwadratową:
        \[ f(x) = -\left(7 - x\right)^2 + 2 \]

        Jak widać na wykresie funkcji~\ref{fig:funkcja_rownomiernosc}, jej głównym zadaniem jest karanie dni o skrajnym obciążeniu dydaktycznym zarówno dla nauczycieli, jak i uczniów.
        Wierzchołek funkcji umieściłem w punkcie $x = 7$, a nie $x = 8$, ponieważ pięciogodzinny dzień pracy jest znacznie bardziej akceptowalny niż dziesięciogodzinny.
        Funkcja nagradza wartości z przedziału $(5, 9)$, przy czym wartości bliskie 7 otrzymują maksymalną ocenę.
        Wartości spoza tego przedziału są znacząco karane, co zapewnia spełnienie dwóch kluczowych warunków: brak ponad dziesięciogodzinnych dni pracy dla nauczycieli oraz utrzymanie około siedmiogodzinnych dni lekcyjnych dla uczniów.

        Nawet w przypadkach, gdy program nauczania przekracza $35$ godzin tygodniowo (co uniemożliwia dodatnią wartość tej funkcji przy równomiernym rozłożeniu), funkcja zachowuje swoją przydatność w zapewnianiu zgodności z wymaganiami równomiernych rozkładów godzin.
        Ze względu na malejącą pochodną w przedziale $[7, +\infty)$, rozwiązania z jednym dniem 7-godzinnym kosztem dnia 11-godzinnego otrzymują gorszą ocenę niż rozwiązania z dwoma dniami 9-godzinnymi, co promuje bardziej zrównoważony rozkład obciążenia. będą gorzej oceniane niż osobniki z dwoma dniami o 9 godzinach.

        \begin{figure}[h]
            \centering
            \begin{tikzpicture}
                \begin{axis}[
                    width=0.9\textwidth,
                    height=8cm,
                    axis lines = middle,
                    xlabel = $x$,
                    ylabel = $y$,
                    xmin=0, xmax=14,
                    ymin=-50, ymax=10,
                    tick style={black},
                    samples=100,
                    domain=0:14,
                ]
                
                    \addplot [blue, thick] {-(7-x)^2 + 2};
                    \node at (axis cs:7,2) [above] {\((7,2)\)};
                \end{axis}
            \end{tikzpicture}
            \caption{Wykres funkcji użytej do ewaluacji rozkładu godzin nauczycieli i klas na przestrzeni tygodnia.}
            \label{fig:funkcja_rownomiernosc}
        \end{figure}

        \subsubsection{Ocena względem nauczycieli}
            Ocena równomierności rozpoczyna się od obliczenia dla każdego nauczyciela wektora obciążenia godzinowego:
            \[ X_i = \begin{bmatrix} x_{i,1} & x_{i,2} & x_{i,3} & x_{i,4} & x_{i,5} \end{bmatrix} \]
            gdzie $x_{i,d}$ oznacza liczbę godzin lekcyjnych do przeprowadzenia przez $i$-tego nauczyciela $d$-tego dnia.
            
            Problemem funkcji kwadradowej jest fakt, że osobniki otrzymują dużą karę, kiedy zgodnie z przydziałem nauczyciel ma dzień wolny --- jest to niezgodne z założeniami.
            Wolimy, aby nauczyciej miał cztery dni 8-godzinne niż pięć dni po 6 lub 7 godzin.
            Aby osiągnąć taką właściwość zeruję wartość funkcji dla $x=0$, co skutkuje następującą funkcją:
            \[
                \begin{cases*}
                    f_T(x) = 0 & x = 0\\
                    f_T(x) = -\left(7-x\right)^2 + 2 & \text{ wpp.}\\
                \end{cases*}
            \]
            
            Następnie wyznaczam sumę wartości funkcji dla wszystkich argumentów tego wektora:
            \[ F_{c_{T_i}} = \sum_{d=1}^{5} f_T(x_{i,d}) \]
            gdzie $\left|\mathcal{T}\right|$ to liczba wszystkich nauczycieli.

            Końcowa ocena wszystkich nauczycieli to najzwyczajniej suma wszystkich wartości:
            \[ F_{c_T} = \sum_{i=1}^{\left|\mathcal{T}\right|} F_{c_{T_i}} \]

        \subsubsection{Ocena względem klas}
            Ocena równomierności z respektem do klas jest analogiczna do poprzedniej.
            Tworzony jest wektor obciążenia godzinowego:
            \[ X_i = \begin{bmatrix} x_{i,1} & x_{i,2} & x_{i,3} & x_{i,4} & x_{i,5} \end{bmatrix} \]
            gdzie $g_{i,d}$ oznacza liczbę godzin lekcyjnych przez $i$-tej klasy $d$-tego dnia.

            W tym przypadku dni wolne nie są zgodne ze względu na ograniczenia opisane w~\ref{subsection:ograniczenia}, a więc modyfikacje funkcji nie są potrzebne.

            Analogicznie do nauczycieli tworzymy kolejno wektory i wartości:

            \noindent
            \begin{minipage}{.48\textwidth}
                \[ F_{c_{C_i}} = \sum_{d=1}^{5} f(x_{i,d}) \]
            \end{minipage}
            \begin{minipage}{.48\textwidth}
                \[ F_{c_C} = \sum_{i=1}^{\left|\mathcal{C}\right|} F_{c_{C_i}} \]
            \end{minipage}\\
            gdzie $\left|\mathcal{C}\right|$ to liczba wszystkich klas.

        \subsubsection{Normalizacja i wagi}
            Wyznaczanie końcowej wartości funkcji przystosowania wymaga uwzględnienia stosuneku liczby nauczycieli do liczby uczniów.
            W typowych placówkach oświatowych liczba nauczycieli przywyższa liczbę klas.
            Bezpośrednie dodawanie ocen $F_{c_T} + F_{c_G}$ prowadziłoby do znaczącej dominacji oceny nauczycieli w ocenie końcowej.
            W celu rozwiązania tego problemu zastosowałem normalizację poprzez dzielenie każdej składowej przez odpowiednio $\left|\mathcal{T}\right|$ i $\left|\mathcal{C}\right|$.
            Takie podejście gwarantuje, że wpływ pojedynczej klasy na ocenę końcową jest porównywalny z wpływem pojedynczego nauczyciela.

            Kolejnym aspektem wymagającym uwzględnienia jest relatywna ważność obu kryteriów oceny. 
            W praktyce, wymagania równomiernego rozkładu dla każdej klasy są ważniejsze niż równomierny rozkład godzin nauczycieli.
            Aby umożliwić sterowanie tymi preferencjami należy zaimplementować wagi, co prowadzi do następującej postaci funkcji przystosowania:
            \[ F_c = \frac{\alpha_T}{\left|\mathcal{T}\right|} F_{c_T} + \frac{\alpha_G}{\left|\mathcal{C}\right|} F_{c_G}, \quad \alpha_T, \alpha_T \in \mathbb{R}^+ \]
            gdzie $\alpha_T$ to waga oceny nauczycieli, a $\alpha_G$ to waga oceny klas.

    \subsection{Selekcja}\label{subsection:selekcja}
        Zastosowałem traducyjną metodę ruletkową. Polega ona na losowaniu osobników, którzy posłużą jako rodzice z prawdopodobieństwami, które sa proporcjonalne do wartości ich funkcji przystowania.
        Mając wektor ocen $F_{c\text{ total}} = \begin{bmatrix} F_{c_1} & F_{c_1} & \cdots & F_{c_\mathfrak{P}} \end{bmatrix}$, gdzie $\mathfrak{P}$ to rozmiar populacji, sortujemy go i dzielimy go na pół.
        Drugą połowę populacji, która ma najgorsze wyniki, usuwam i na jej miejsce wstawiam potomków rodziców wylosowanych zgodnie z prawdopodobieństwami:
        \[ P = \begin{bmatrix} \sigma\left(F_{c_1}\right) & \sigma\left(F_{c_2}\right) & \cdots & \sigma\left(F_{c_\mathfrak{P}}\right) \end{bmatrix}, \quad \sigma(F_{c_i}) = \frac{\exp\left[F_{c_i}\right]}{\sum_{j=1}^{\mathfrak{P}} \exp\left[F_{c_j}\right] } \]
        W celu zamiany funkcji przystosowania na prawdopodobieństwa użyłem funkcji SoftMax.

    \subsection{Krzyżowanie}\label{subsection:krzyzowanie}
        Największym wyzwaniem podczas projektowania algorytmu okazało się opracowanie krzyżowania osobników, które zagwarantowałoby spójność z nałożonymi ograniczeniami.
        Niemożność zaimplementowania takich rozwiązań jak proste modyfikowanie krzyżowania jednopunktowego zmusiło mnie do opracowania specjalistycznych metod.

        Z uwagi na dwie składowe funkcji zdecydowałem się na zaimplementowanie dwóch niezależnych metod krzyżowania osobników.
        Takie podejście umożliwia równoczesne dziedziczenie cech związanych z optymalnym rozkładem zajęć zarówno z perspektywy nauczycieli, jak i klas.
        Pozwala to także na stworzenie dwóch różnych potomków z dwóch rodziców.

        \subsubsection{Względem oceny nauczycieli}
            Funkcja krzyżowania uwzględniająca ocenę rozkładu godzin nauczycieli definiuje się następująco:

            \noindent
            \textbf{Dane wejściowe:}
                \begin{itemize}
                    \item $S_1$ --- pierwszy rodzic
                    \item $S_2$ --- drugi rodzic
                    \item $F_{T_{S_1}}$ --- ocena nauczycieli pierwszego osobnika
                    \item $F_{T_{S_2}}$ --- ocena nauczycieli drugiego osobnika
                \end{itemize}
            
            \noindent
            \textbf{Proces:}
            \begin{enumerate}
                \item Inicjalizacja macierzy potomka: $S_{\text{child}} = \mathbf{0}_{5 \times \mathfrak{N}}$
                \item Dla każdego nauczyciela $i \in {1, 2, \dots, \left|\mathcal{T}\right|}$:
                \begin{enumerate}
                    \item Jeżeli $F_{T_{i,S_1}} > F_{T_{i,S_2}}$, to dla każdego bloku $j$ prowadzonego przez nauczyciela $i$:
                    \begin{enumerate}
                        \item Przepisz kolumnę $j$ z macierzy $S_1$ do kolumny $j$ macierzy $S_{\text{child}}$
                    \end{enumerate}
                    \item W przeciwnym przypadku, dla każdego bloku $j$ prowadzonego przez nauczyciela $i$:
                    \begin{enumerate}
                        \item Przepisz kolumnę $j$ z macierzy $S_2$ do kolumny $j$ macierzy $S_{\text{child}}$
                    \end{enumerate}
                \end{enumerate}
            \end{enumerate}

            Wygenerowany w ten sposób osobnik $S_{\text{child}}$ ma cechy, które gwarantują jak najlepsze przypisanie nauczycieli wśród obu rodziców.
            Następną zaletą tego podejścia jest fakt, że gwarantuje to też także spełnienie wszystkich wymagań,
            jako że wszystkie wymagania odnoszą się do indywidualnych bloków, a tych nie zmieniamy, tylko przepisujemy.

        \subsubsection{Względem oceny klas}
            Analogicznie definiujemy krzyżowanie względem oceny klas:

            \noindent
            \textbf{Dane wejściowe:}
                \begin{itemize}
                    \item $S_1$ --- pierwszy rodzic
                    \item $S_2$ --- drugi rodzic
                    \item $F_{G_{S_1}}$ --- ocena klas pierwszego osobnika
                    \item $F_{G_{S_2}}$ --- ocena klas drugiego osobnika
                \end{itemize}
            
            \noindent
            \textbf{Proces:}
            \begin{enumerate}
                \item Inicjalizacja macierzy potomka: $S_{\text{child}} = \mathbf{0}_{5 \times \mathfrak{N}}$
                \item Dla każdej klasy $i \in {1, 2, \dots, \left|\mathcal{C}\right|}$:
                \begin{enumerate}
                    \item Jeżeli $F_{G_{i,S_1}} > F_{G_{i,S_2}}$, to dla każdego bloku $j$ prowadzonego dla klasy $i$:
                    \begin{enumerate}
                        \item Przepisz kolumnę $j$ z macierzy $S_1$ do kolumny $j$ macierzy $S_{\text{child}}$
                    \end{enumerate}
                    \item W przeciwnym przypadku, dla każdego bloku $j$ prowadzonego przez nauczyciela $i$:
                    \begin{enumerate}
                        \item Przepisz kolumnę $j$ z macierzy $S_2$ do kolumny $j$ macierzy $S_{\text{child}}$
                    \end{enumerate}
                \end{enumerate}
            \end{enumerate}

            Wygenerowany w ten sposób osobnik $S_{\text{child}}$ ma cechy, które gwarantują jak najlepszy rozkład godzin lekcyjnych dla klas wśród obu rodziców.
            Podobnie w tym przypadku nie modyfikujemy przydziału godzin w indywidualnych blokach, więc zachowujemy zgodność z ograniczeniami.

    \subsection{Mutacja}\label{subsection:mutacja}
        Analogicznie do przypadku krzyżowania, zastosowanie prostych metod mutacji (takich jak losowa zamiana pojedynczych przydziałów) nie jest możliwe ze względu na wysokie ryzyko naruszenia ograniczeń.
        W szczególności, modyfikacja pojedynczych wartości macierzy $S$ może prowadzić do niezgodności z warunkiem głównym bloków.
        
        W odpowiedzi na to wyzwanie, przyjąłem strategię mutacji operującą na poziomie bloków --- kolumn macierzy przydziałów, podobną do podejścia zastosowanego w funkcji krzyżowania.
        Pozwana to na zachowania zgodności z ograniczeniami.
        
        \begin{samepage}
            Procedura mutacji definiuje się następująco:
            \begin{enumerate}
                \item Z populacji wybieranych jest losowo $n$ osobników.
                \item Dla każdego wybranego osobnika wybierany jest losowy podzbiór kolumn (bloków lekcyjnych).
                \item Dla każdej wybranej kolumny $j$ wylosuj nowy przydział zgodnie z procedurą opisaną w podrozdziale~\ref{subsection:generowanie_populacji}.
            \end{enumerate}
        \end{samepage}
        
        Takie podejście gwarantuje, że zmutowane osobniki zachowują zgodność z podstawowymi ograniczeniami problemu, jednocześnie wprowadzając do populacji nowe warianty rozkładów godzinowych wybranych bloków lekcyjnych.

        W celu zwiększenia stabilności procesu ewolucyjnego zaimplementowałem także elitarnego osobnika, który zawsze pojawia się niezmieniony w następnej generacji.
        Jest to osobik o największej wartości funkcji przystosowania:
        \[ S_{\text{best}} = S_i, \quad i = \underset{j \in \left\{1, 2, \dots \mathfrak{P}\right\}}{\arg\max} F_{c_j} \]

    \subsection{Przykładowe rezultaty}
        \textit{Przykładowe macierze z opisami}

\section{Solver liniowy}
    \textit{Wyjaśnienie czym jest solver liniowy}

    Opisany poniżej proces jest wykonywany niezależnie dla każdego dnia tygodnia, reprezentowanego przez wiersze macierzy $S_{\text{best}}$.
    Takie podejście umożliwia dekompozycję problemu na pięć mniejszych, niezależnych podproblemów, co znacząco redukuje wymagania obliczeniowe i zużycie pamięci RAM.

    \begin{samepage}
        \subsection{Czym są interwały}
            W odpowiedzi na wyzwania napotkane w podejściu opisanym w podrozdziale~\ref{subsection:podejscie_zerojedynkowe} zdecydowałem się na eksplorację innych sposobów reprezentacji lekcji niż zmienne binarne.
            W tym procesie napotkałem się na opisane przez Google \verb|Interval Variables|~\cite{googleortoolsintervalvar}.
            Są one sposobem reprezentacji interwałów poprzez trzy powiązane zmienne, z fundamentalnym ograniczeniem:
            \vspace*{1em}

            \noindent
            \begin{minipage}[t]{.48\textwidth}
                \textbf{Zmienne:}
                \begin{itemize}
                    \item $s$ --- czas rozpoczęcia
                    \item $d$ --- czas trwania
                    \item $e$ --- czas zakończenia
                \end{itemize}
            \end{minipage}\hfill
            \begin{minipage}[t]{.48\textwidth}
                \textbf{Ograniczenie:}
                \[ e - s = d \]
            \end{minipage}

            \vspace*{1em}
            OR-Tools oferuje także \verb|OptionalIntervals|, które które reprezentuje interwał z dodatkową zmienna \verb|is_present|, która decyduje o tym czy interwał jest aktywny przy sprawdzaniu ogarniczeń. Traktowana jest jako zmienna zerojedynkowa przy dodawaniu:
            \vspace*{1em}

            \noindent
            \begin{minipage}[t]{.48\textwidth}
                \textbf{Zmienne:}
                \begin{itemize}
                    \item $s$ --- czas rozpoczęcia
                    \item $d$ --- czas trwania
                    \item $e$ --- czas zakończenia
                    \item \verb|is_present| --- zmienna logiczna
                \end{itemize}
            \end{minipage}\hfill
            \begin{minipage}[t]{.48\textwidth}
                \textbf{Ograniczenie:}
                \[ \verb|is_present| \implies e - s = d \]
            \end{minipage}
    \end{samepage}

    \subsection{Zmienne decyzyjne oraz wymagania ilościowe sal}
        Dla każdego bloku lekcyjnego $b_i$ dla którego $v_i > 0$ definiujemy:
        \begin{enumerate}
            \item $s_i \gets \verb|NewIntVar(0, horizon)|$
            \item $e_i \gets \verb|NewIntVar(0, horizon)|$
            \item $\verb|Interval|_i \gets \verb|NewIntervalVar(|s_i\verb|, |s_{\text{best}_{d, i}}\verb|, |e_i\verb|)|$
        \end{enumerate}

        Dla każdego przedmiotu $z$ oraz liczby nauczycieli $\left|\mathcal{T}\right|_{i,z}$ prowadzących ten przedmiot w bloku $b_i$ definiujemy:
        \begin{enumerate}
            \item $\forall r \in \left\{1, 2, \dots, \mathfrak{R}_z\right\}$:
            \begin{enumerate}
                \item $\verb|is_present|_{i,j,r} \gets \verb|NewBoolVar()|$
                \item $\verb|OptionalInterval|_{i,j,r} \gets \verb|NewOptionalIntervalVar(|s_i\verb|, |s_{\text{best}_{d, i}}\verb|, |e_i\verb|, is_present|_{i,j}\verb|)|$\\
            \end{enumerate}
            gdzie $j \in \left\{1, 2, \dots, \left|\mathcal{T}\right|_{i, z}\right\}$, oraz $\mathfrak{R}_z$ to liczba sal obsługujących przedmiot $z$.
            \item Na tym etapie dodajemy także ograniczenie do modelu:
            \[ \sum_{r=1}^{\mathfrak{R}_z}\sum_{j=1}^{\left|\mathcal{T}\right|_{i,z}}\verb|is_present|_{i,j,r} = \left|\mathcal{T}\right|_{i,z} \]
        \end{enumerate}
        Wszystkie zdefiniowane ograniczenia w tens posób możemy wyrazić językiem naturalnym jako:\\ ``Liczba sal przypisanych do bloku musi być równa liczbie nauczycieli w bloku $b_i$ oraz przypisane sale muszą obsługiwać przedmioty prowadzone w ramach bloku $b_i$''.

    \subsection{Ograniczenia}
        \subsubsection{Dwa takie same przedmioty muszą być obok siebie}
            Jedną z licznych zalet stosowania interwałów do reprezentacji bloków lekcyjnych jest fakt, że sama ich definicja gwarantuje nam następstwo takich samych bloków.
            Tworzymy bloki o długości $s_{d, i}$, co za tym idzie jeśli dwie godziny są przypisane do danego dnia

        \subsubsection{Nienakładanie się lekcji dla każdej klasy i brak okienek dla uczniów}
            Dla każdej klasy $g$ wykonujemy następującą procedurę:
            \begin{enumerate}
                \item Tworzymy listę indeksów bloków/interwałów $D_g$, których bloki obejmują rozpatrywaną klasę $g$.
                \item Dodajemy ograniczenie $\verb|model.AddNoOverlap([Interval|_i \verb| for | i \verb| in | D_g \verb|])|$
                \item Tworzymy dwie zmienne pomocnicze:
                \begin{itemize}
                    \item $\verb|day_start| \gets \verb|model.NewIntVar(0, horizon)|$
                    \item $\verb|day_end| \gets \verb|model.NewIntVar(0, horizon)|$
                \end{itemize}
                \item Dodajemy następujące ograniczenia:
                \begin{enumerate}
                    \item $\verb|day_start| = \underset{i \in D_g}{\min}\left\{s_i\right\}$
                    \item $\verb|day_end  | = \underset{i \in D_g}{\max}\left\{e_i\right\}$
                    \item $\verb|day_end| - \verb|day_start| = \mathlarger\sum_{i \in D_g} v_i$
                \end{enumerate}
            \end{enumerate}
            
        \subsubsection{Nienakładanie się lekcji dla każdego nauczyciela}
            Dla każdego nauczyciela $t$ wykonujemy:
            \begin{enumerate}
                \item Tworzymy listę indeksów bloków/interwałów $D_t$, których bloki obejmują rozpatrywanego nauczyciela $t$.
                \item Dodajemy ograniczenie $\verb|model.AddNoOverlap([Interval|_i \verb| for | i \verb| in | D_t \verb|])|$
            \end{enumerate}
        
        \subsubsection{Nienakładanie się lekcji w jednej sali}
            Dla każdej sali $r$ wykonujemy:
            \begin{enumerate}
                \item Tworzymy listę wszystkich istniejących opcjonalnych interwałów 
                \[ \verb|room_intervals|_r = \left[\verb|OptionalInterval|_{i,j,r}\right], \quad \forall i \in \left\{1, 2, \dots, \mathfrak{N}\right\}, \forall j \in \left\{1, 2, \dots, \left|\mathcal{T}\right|\right\} \]
                \item Dodajemy ograniczenie $\verb|model.AddNoOverlap(room_intervals|_r\verb|)|$
            \end{enumerate}

    \subsection{Funkcja celu}
        Funkcja celu ma na celu minimalizację czasu spędzanego przez nauczycieli w szkole, co pośrednio redukuje liczbę okienek.
        Możemy w tym celu użyć bardzo podobnej architektury jak w ograniczeniu, które gwarantuje ciągłość lekcji dla każdej klasy.

        Stwórzymy zmienne dla każdego nauczyciela $t$:
        \begin{itemize}
            \item $\verb|day_start| \gets \verb|model.NewIntVar(0, horizon)|$
            \item $\verb|day_end| \gets \verb|model.NewIntVar(0, horizon)|$
            \item $\verb|day_duration|_t = \verb|day_end| - \verb|day_start|$
        \end{itemize}

        Dodajmy następujące ograniczenia:
        \begin{enumerate}
            \item $\verb|day_start| = \underset{i \in D_t}{\min}\left\{s_i\right\}$
            \item $\verb|day_end  | = \underset{i \in D_t}{\max}\left\{e_i\right\}$
        \end{enumerate}

        Funkcja celu ma postać:
        \[ F_c = \sum_{t=1}^{\left|\mathcal{T}\right|} \verb|day_duration|_t \]
        Minimalizacja tej funkcji prowadzi do kompaktowego układania zajęć, redukując okienka w planach nauczycieli.


\section{Wyniki}
    \begin{itemize}
        \item Dlaczego moje wyniki są wspaniałe
        \item Średni czas potrzebny na generację planu
    \end{itemize}

    \subsection{Statystyki planu}
        \begin{itemize}
            \item Ilość okienek
            \item Rozkład lekcji w tygodniu
            \item Lekcje początkujące/kończące
            \item Statystyki nauczycieli, godziny w szkole do godzin lekcyjnych (płatnych)
        \end{itemize}

    \subsection{Porównanie z ręcznie ułożonym planem}
        Porównanie z planem, który szkoła ułożyła ręcznie.